{"ast":null,"code":"var _jsxFileName = \"/Users/praneetha18/Downloads/games-app-main/src/components/Chess/ui/ChessBoard.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport Game from '../model/Chess';\nimport Square from '../model/Square';\nimport { Stage, Layer } from 'react-konva';\nimport Board from '../assets/chessBoard.png';\nimport Piece from './Piece';\nimport piecemap from './PieceMap';\nimport './ChessBoard.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst socket = require('../apis/scoket').socket;\nconst ChessBoard = props => {\n  _s();\n  const navigate = useNavigate();\n  const [gameState, setgameState] = useState(new Game(props.color));\n  const [draggedPieceTargetId, setdraggedPieceTargetId] = useState(\"\");\n  const [playerTurnToMoveIsWhite, setplayerTurnToMoveIsWhite] = useState(true);\n  const [whiteKingInCheck, setwhiteKingInCheck] = useState(false);\n  const [blackKingInCheck, setblackKingInCheck] = useState(false);\n  useEffect(() => {\n    console.log(\"My User Name: \", props.myUserName);\n    console.log(\"Opponent User Name: \", props.opponentUserName);\n\n    // register event listeners\n    socket.on('opponent move', move => {\n      // move == [pieceId, finalPosition]\n      // console.log(\"opponenet's move: \" + move.selectedId + \", \" + move.finalPosition)\n      if (move.playerColorThatJustMovedIsWhite !== props.color) {\n        movePiece(move.selectedId, move.finalPosition, gameState, false);\n        setplayerTurnToMoveIsWhite(!move.playerColorThatJustMovedIsWhite);\n      }\n    });\n  }, []);\n  const startDragging = e => {\n    setdraggedPieceTargetId(e.target.attrs.id);\n  };\n  const movePiece = (selectedId, finalPosition, currentGame, isMyMove) => {\n    /**\n     * \"update\" is the connection between the model and the UI. \n     * This could also be an HTTP request and the \"update\" could be the server response.\n     * (model is hosted on the server instead of the browser)\n     */\n    var whiteKingInCheck = false;\n    var blackKingInCheck = false;\n    var blackCheckmated = false;\n    var whiteCheckmated = false;\n    const update = currentGame.movePiece(selectedId, finalPosition, isMyMove);\n    if (update === \"moved in the same position.\") {\n      revertToPreviousState(selectedId); // pass in selected ID to identify the piece that messed up\n      return;\n    } else if (update === \"user tried to capture their own piece\") {\n      revertToPreviousState(selectedId);\n      return;\n    } else if (update === \"b is in check\" || update === \"w is in check\") {\n      // change the fill of the enemy king or your king based on which side is in check. \n      // play a sound or something\n      if (update[0] === \"b\") {\n        blackKingInCheck = true;\n      } else {\n        whiteKingInCheck = true;\n      }\n    } else if (update === \"b has been checkmated\" || update === \"w has been checkmated\") {\n      if (update[0] === \"b\") {\n        blackCheckmated = true;\n      } else {\n        whiteCheckmated = true;\n      }\n    } else if (update === \"invalid move\") {\n      revertToPreviousState(selectedId);\n      return;\n    }\n\n    // let the server and the other client know your move\n    if (isMyMove) {\n      console.log(\"My Move\", isMyMove);\n      socket.emit('new move', {\n        nextPlayerColorToMove: !gameState.thisPlayersColorIsWhite,\n        playerColorThatJustMovedIsWhite: gameState.thisPlayersColorIsWhite,\n        selectedId: selectedId,\n        finalPosition: finalPosition,\n        gameId: props.gameId\n      });\n    }\n    props.playAudio();\n\n    // sets the new game state. \n    setdraggedPieceTargetId(\"\");\n    setgameState(currentGame);\n    setplayerTurnToMoveIsWhite(!props.color);\n    setwhiteKingInCheck(whiteKingInCheck);\n    setblackKingInCheck(blackKingInCheck);\n    if (blackCheckmated) {\n      alert(\"WHITE WON BY CHECKMATE!\");\n      navigate('/');\n    } else if (whiteCheckmated) {\n      alert(\"BLACK WON BY CHECKMATE!\");\n      navigate('/');\n    }\n  };\n  const revertToPreviousState = selectedId => {\n    /**\n     * Should update the UI to what the board looked like before. \n     */\n    const oldGS = gameState;\n    const oldBoard = oldGS.getBoard();\n    const tmpGS = new Game(true);\n    const tmpBoard = [];\n    for (var i = 0; i < 8; i++) {\n      tmpBoard.push([]);\n      for (var j = 0; j < 8; j++) {\n        if (oldBoard[i][j].getPieceIdOnThisSquare() === selectedId) {\n          tmpBoard[i].push(new Square(j, i, null, oldBoard[i][j].canvasCoord));\n        } else {\n          tmpBoard[i].push(oldBoard[i][j]);\n        }\n      }\n    }\n\n    // temporarily remove the piece that was just moved\n    tmpGS.setBoard(tmpBoard);\n    setgameState(tmpGS);\n    setdraggedPieceTargetId(\"\");\n    setgameState(oldGS);\n  };\n  const endDragging = e => {\n    const currentGame = gameState;\n    const currentBoard = currentGame.getBoard();\n    const finalPosition = inferCoord(e.target.x() + 90, e.target.y() + 90, currentBoard);\n    const selectedId = draggedPieceTargetId;\n    movePiece(selectedId, finalPosition, currentGame, true);\n  };\n  const inferCoord = (x, y, chessBoard) => {\n    // console.log(\"actual mouse coordinates: \" + x + \", \" + y)\n    /*\n        Should give the closest estimate for new position. \n    */\n    var hashmap = {};\n    var shortestDistance = Infinity;\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        const canvasCoord = chessBoard[i][j].getCanvasCoord();\n        // calculate distance\n        const delta_x = canvasCoord[0] - x;\n        const delta_y = canvasCoord[1] - y;\n        const newDistance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n        hashmap[newDistance] = canvasCoord;\n        if (newDistance < shortestDistance) {\n          shortestDistance = newDistance;\n        }\n      }\n    }\n    return hashmap[shortestDistance];\n  };\n  return /*#__PURE__*/_jsxDEV(React.Fragment, {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        backgroundImage: `url(${Board})`,\n        width: \"720px\",\n        height: \"720px\"\n      },\n      children: /*#__PURE__*/_jsxDEV(Stage, {\n        width: 720,\n        height: 720,\n        children: /*#__PURE__*/_jsxDEV(Layer, {\n          children: gameState.getBoard().map((row, idx1) => {\n            return /*#__PURE__*/_jsxDEV(React.Fragment, {\n              children: row.map((square, idx2) => {\n                if (square.isOccupied()) {\n                  return /*#__PURE__*/_jsxDEV(Piece, {\n                    x: square.getCanvasCoord()[0],\n                    y: square.getCanvasCoord()[1],\n                    imgurls: piecemap[square.getPiece().name],\n                    isWhite: square.getPiece().color === \"white\",\n                    draggedPieceTargetId: draggedPieceTargetId,\n                    onDragStart: startDragging,\n                    onDragEnd: endDragging,\n                    id: square.getPieceIdOnThisSquare(),\n                    thisPlayersColorIsWhite: props.color,\n                    playerTurnToMoveIsWhite: playerTurnToMoveIsWhite,\n                    whiteKingInCheck: whiteKingInCheck,\n                    blackKingInCheck: blackKingInCheck\n                  }, idx1 + \"\" + idx2, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 183,\n                    columnNumber: 45\n                  }, this);\n                }\n                return;\n              })\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 179,\n              columnNumber: 37\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 177,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 176,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 169,\n    columnNumber: 9\n  }, this);\n};\n_s(ChessBoard, \"YGvdCFkf9AUt4FfS6ttqX+D6yLw=\", false, function () {\n  return [useNavigate];\n});\n_c = ChessBoard;\nexport default ChessBoard;\nvar _c;\n$RefreshReg$(_c, \"ChessBoard\");","map":{"version":3,"names":["React","useEffect","useState","useNavigate","Game","Square","Stage","Layer","Board","Piece","piecemap","socket","require","ChessBoard","props","navigate","gameState","setgameState","color","draggedPieceTargetId","setdraggedPieceTargetId","playerTurnToMoveIsWhite","setplayerTurnToMoveIsWhite","whiteKingInCheck","setwhiteKingInCheck","blackKingInCheck","setblackKingInCheck","console","log","myUserName","opponentUserName","on","move","playerColorThatJustMovedIsWhite","movePiece","selectedId","finalPosition","startDragging","e","target","attrs","id","currentGame","isMyMove","blackCheckmated","whiteCheckmated","update","revertToPreviousState","emit","nextPlayerColorToMove","thisPlayersColorIsWhite","gameId","playAudio","alert","oldGS","oldBoard","getBoard","tmpGS","tmpBoard","i","push","j","getPieceIdOnThisSquare","canvasCoord","setBoard","endDragging","currentBoard","inferCoord","x","y","chessBoard","hashmap","shortestDistance","Infinity","getCanvasCoord","delta_x","delta_y","newDistance","Math","sqrt","backgroundImage","width","height","map","row","idx1","square","idx2","isOccupied","getPiece","name"],"sources":["/Users/praneetha18/Downloads/games-app-main/src/components/Chess/ui/ChessBoard.js"],"sourcesContent":["import React, { useEffect, useState } from 'react'\nimport { useNavigate } from 'react-router-dom'\nimport Game from '../model/Chess'\nimport Square from '../model/Square'\nimport { Stage, Layer } from 'react-konva';\nimport Board from '../assets/chessBoard.png'\nimport Piece from './Piece'\nimport piecemap from './PieceMap'\nimport './ChessBoard.css'\nconst socket = require('../apis/scoket').socket\n\nconst ChessBoard = (props) => {\n    const navigate = useNavigate()\n    const [gameState, setgameState] = useState(new Game(props.color))\n    const [draggedPieceTargetId, setdraggedPieceTargetId] = useState(\"\")\n    const [playerTurnToMoveIsWhite, setplayerTurnToMoveIsWhite] = useState(true)\n    const [whiteKingInCheck, setwhiteKingInCheck] = useState(false)\n    const [blackKingInCheck, setblackKingInCheck] = useState(false)\n\n    useEffect(() => {\n\n        console.log(\"My User Name: \", props.myUserName)\n        console.log(\"Opponent User Name: \", props.opponentUserName)\n\n        // register event listeners\n        socket.on('opponent move', move => {\n            // move == [pieceId, finalPosition]\n            // console.log(\"opponenet's move: \" + move.selectedId + \", \" + move.finalPosition)\n            if (move.playerColorThatJustMovedIsWhite !== props.color) {\n                movePiece(move.selectedId, move.finalPosition, gameState, false)\n                setplayerTurnToMoveIsWhite(!move.playerColorThatJustMovedIsWhite)\n            }\n        })\n\n    }, [])\n\n    const startDragging = (e) => {\n        setdraggedPieceTargetId(e.target.attrs.id)\n    }\n\n    const movePiece = (selectedId, finalPosition, currentGame, isMyMove) => {\n        /**\n         * \"update\" is the connection between the model and the UI. \n         * This could also be an HTTP request and the \"update\" could be the server response.\n         * (model is hosted on the server instead of the browser)\n         */\n        var whiteKingInCheck = false\n        var blackKingInCheck = false\n        var blackCheckmated = false\n        var whiteCheckmated = false\n        const update = currentGame.movePiece(selectedId, finalPosition, isMyMove)\n\n        if (update === \"moved in the same position.\") {\n            revertToPreviousState(selectedId) // pass in selected ID to identify the piece that messed up\n            return\n        } else if (update === \"user tried to capture their own piece\") {\n            revertToPreviousState(selectedId)\n            return\n        } else if (update === \"b is in check\" || update === \"w is in check\") {\n            // change the fill of the enemy king or your king based on which side is in check. \n            // play a sound or something\n            if (update[0] === \"b\") {\n                blackKingInCheck = true\n            } else {\n                whiteKingInCheck = true\n            }\n        } else if (update === \"b has been checkmated\" || update === \"w has been checkmated\") {\n            if (update[0] === \"b\") {\n                blackCheckmated = true\n            } else {\n                whiteCheckmated = true\n            }\n        } else if (update === \"invalid move\") {\n            revertToPreviousState(selectedId)\n            return\n        }\n\n        // let the server and the other client know your move\n        if (isMyMove) {\n            console.log(\"My Move\", isMyMove)\n            socket.emit('new move', {\n                nextPlayerColorToMove: !gameState.thisPlayersColorIsWhite,\n                playerColorThatJustMovedIsWhite: gameState.thisPlayersColorIsWhite,\n                selectedId: selectedId,\n                finalPosition: finalPosition,\n                gameId: props.gameId\n            })\n        }\n\n        props.playAudio()\n\n        // sets the new game state. \n        setdraggedPieceTargetId(\"\")\n        setgameState(currentGame)\n        setplayerTurnToMoveIsWhite(!props.color)\n        setwhiteKingInCheck(whiteKingInCheck)\n        setblackKingInCheck(blackKingInCheck)\n\n        if (blackCheckmated) {\n            alert(\"WHITE WON BY CHECKMATE!\")\n            navigate('/')\n        } else if (whiteCheckmated) {\n            alert(\"BLACK WON BY CHECKMATE!\")\n            navigate('/')\n        }\n    }\n\n    const revertToPreviousState = (selectedId) => {\n        /**\n         * Should update the UI to what the board looked like before. \n         */\n        const oldGS = gameState\n        const oldBoard = oldGS.getBoard()\n        const tmpGS = new Game(true)\n        const tmpBoard = []\n\n        for (var i = 0; i < 8; i++) {\n            tmpBoard.push([])\n            for (var j = 0; j < 8; j++) {\n                if (oldBoard[i][j].getPieceIdOnThisSquare() === selectedId) {\n                    tmpBoard[i].push(new Square(j, i, null, oldBoard[i][j].canvasCoord))\n                } else {\n                    tmpBoard[i].push(oldBoard[i][j])\n                }\n            }\n        }\n\n        // temporarily remove the piece that was just moved\n        tmpGS.setBoard(tmpBoard)\n\n        setgameState(tmpGS)\n        setdraggedPieceTargetId(\"\")\n        setgameState(oldGS)\n    }\n\n    const endDragging = (e) => {\n        const currentGame = gameState\n        const currentBoard = currentGame.getBoard()\n        const finalPosition = inferCoord(e.target.x() + 90, e.target.y() + 90, currentBoard)\n        const selectedId = draggedPieceTargetId\n        movePiece(selectedId, finalPosition, currentGame, true)\n    }\n\n    const inferCoord = (x, y, chessBoard) => {\n        // console.log(\"actual mouse coordinates: \" + x + \", \" + y)\n        /*\n            Should give the closest estimate for new position. \n        */\n        var hashmap = {}\n        var shortestDistance = Infinity\n        for (var i = 0; i < 8; i++) {\n            for (var j = 0; j < 8; j++) {\n                const canvasCoord = chessBoard[i][j].getCanvasCoord()\n                // calculate distance\n                const delta_x = canvasCoord[0] - x\n                const delta_y = canvasCoord[1] - y\n                const newDistance = Math.sqrt(delta_x ** 2 + delta_y ** 2)\n                hashmap[newDistance] = canvasCoord\n                if (newDistance < shortestDistance) {\n                    shortestDistance = newDistance\n                }\n            }\n        }\n\n        return hashmap[shortestDistance]\n    }\n\n    return (\n        <React.Fragment>\n            <div style={{\n                backgroundImage: `url(${Board})`,\n                width: \"720px\",\n                height: \"720px\"\n            }}\n            >\n                <Stage width={720} height={720}>\n                    <Layer>\n                        {gameState.getBoard().map((row,idx1) => {\n                            return (<React.Fragment>\n                                {row.map((square, idx2) => {\n                                    if (square.isOccupied()) {\n                                        return (\n                                            <Piece\n                                                x={square.getCanvasCoord()[0]}\n                                                y={square.getCanvasCoord()[1]}\n                                                imgurls={piecemap[square.getPiece().name]}\n                                                isWhite={square.getPiece().color === \"white\"}\n                                                draggedPieceTargetId={draggedPieceTargetId}\n                                                onDragStart={startDragging}\n                                                onDragEnd={endDragging}\n                                                id={square.getPieceIdOnThisSquare()}\n                                                thisPlayersColorIsWhite={props.color}\n                                                playerTurnToMoveIsWhite={playerTurnToMoveIsWhite}\n                                                whiteKingInCheck={whiteKingInCheck}\n                                                blackKingInCheck={blackKingInCheck}\n                                                key={idx1+\"\"+idx2}\n                                            />)\n                                    }\n                                    return\n                                })}\n                            </React.Fragment>)\n                        })}\n                    </Layer>\n                </Stage>\n            </div>\n        </React.Fragment>)\n}\n\nexport default ChessBoard"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}