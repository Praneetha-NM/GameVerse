{"ast":null,"code":"import { Chess } from 'chess.js';\nimport ChessPiece from './ChessPiece';\nimport Square from './Square';\n// when indexing, remember: [y][x]. \n/**\n * If the player color is black, make sure to invert the board.\n */\n\nclass Game {\n  constructor(thisPlayersColorIsWhite) {\n    this.thisPlayersColorIsWhite = thisPlayersColorIsWhite; // once initialized, this value should never change.\n    // console.log(\"this player's color is white: \" + this.thisPlayersColorIsWhite) \n    this.chessBoard = this.makeStartingBoard(); // the actual chessBoard\n    this.chess = new Chess();\n    this.toCoord = thisPlayersColorIsWhite ? {\n      0: 8,\n      1: 7,\n      2: 6,\n      3: 5,\n      4: 4,\n      5: 3,\n      6: 2,\n      7: 1\n    } : {\n      0: 1,\n      1: 2,\n      2: 3,\n      3: 4,\n      4: 5,\n      5: 6,\n      6: 7,\n      7: 8\n    };\n    this.toAlphabet = thisPlayersColorIsWhite ? {\n      0: \"a\",\n      1: \"b\",\n      2: \"c\",\n      3: \"d\",\n      4: \"e\",\n      5: \"f\",\n      6: \"g\",\n      7: \"h\"\n    } : {\n      0: \"h\",\n      1: \"g\",\n      2: \"f\",\n      3: \"e\",\n      4: \"d\",\n      5: \"c\",\n      6: \"b\",\n      7: \"a\"\n    };\n    this.toCoord2 = thisPlayersColorIsWhite ? {\n      8: 0,\n      7: 1,\n      6: 2,\n      5: 3,\n      4: 4,\n      3: 5,\n      2: 6,\n      1: 7\n    } : {\n      1: 0,\n      2: 1,\n      3: 2,\n      4: 3,\n      5: 4,\n      6: 5,\n      7: 6,\n      8: 7\n    };\n    this.toAlphabet2 = thisPlayersColorIsWhite ? {\n      \"a\": 0,\n      \"b\": 1,\n      \"c\": 2,\n      \"d\": 3,\n      \"e\": 4,\n      \"f\": 5,\n      \"g\": 6,\n      \"h\": 7\n    } : {\n      \"h\": 0,\n      \"g\": 1,\n      \"f\": 2,\n      \"e\": 3,\n      \"d\": 4,\n      \"c\": 5,\n      \"b\": 6,\n      \"a\": 7\n    };\n    this.nQueens = 1;\n  }\n  getBoard() {\n    return this.chessBoard;\n  }\n\n  // nextPlayersTurn() {\n  //     this.isWhitesTurn = !this.isWhitesTurn\n  // }\n\n  setBoard(newBoard) {\n    this.chessBoard = newBoard;\n  }\n  movePiece(pieceId, to, isMyMove) {\n    const to2D = isMyMove ? {\n      105: 0,\n      195: 1,\n      285: 2,\n      375: 3,\n      465: 4,\n      555: 5,\n      645: 6,\n      735: 7\n    } : {\n      105: 7,\n      195: 6,\n      285: 5,\n      375: 4,\n      465: 3,\n      555: 2,\n      645: 1,\n      735: 0\n    };\n    var currentBoard = this.getBoard();\n    const pieceCoordinates = this.findPiece(currentBoard, pieceId);\n\n    // can't find piece coordinates (piece doesn't exist on the board)\n    if (!pieceCoordinates) {\n      return;\n    }\n    const y = pieceCoordinates[1];\n    const x = pieceCoordinates[0];\n\n    // new coordinates\n    const to_y = to2D[to[1]];\n    const to_x = to2D[to[0]];\n    const originalPiece = currentBoard[y][x].getPiece();\n    if (y === to_y && x === to_x) {\n      return \"moved in the same position.\";\n    }\n\n    /**\n     * In order for this method to do anything meaningful, \n     * the 'reassign const' line of code must run. Therefore, \n     * for it to run, we must check first that the given move is valid. \n     */\n\n    const isPromotion = this.isPawnPromotion(to, pieceId[1]);\n    const moveAttempt = !isPromotion ? this.chess.move({\n      from: this.toChessMove([x, y], to2D),\n      to: this.toChessMove(to, to2D),\n      piece: pieceId[1]\n    }) : this.chess.move({\n      from: this.toChessMove([x, y], to2D),\n      to: this.toChessMove(to, to2D),\n      piece: pieceId[1],\n      promotion: 'q'\n    });\n    console.log(moveAttempt);\n    // console.log(isPromotion)\n\n    if (moveAttempt === null) {\n      return \"invalid move\";\n    }\n    if (moveAttempt.flags === 'e') {\n      const move = moveAttempt.to;\n      const x = this.toAlphabet2[move[0]];\n      let y;\n      if (moveAttempt.color === 'w') {\n        y = parseInt(move[1], 10) - 1;\n      } else {\n        y = parseInt(move[1], 10) + 1;\n      }\n      currentBoard[this.toCoord2[y]][x].setPiece(null);\n    }\n\n    // Check castling\n    const castle = this.isCastle(moveAttempt);\n    if (castle.didCastle) {\n      /**\n       *  The main thing we are doing here is moving the right rook\n       *  to the right position. \n       * \n       * - Get original piece by calling getPiece() on the original [x, y]\n       * - Set the new [to_x, to_y] to the original piece\n       * - Set the original [x, y] to null\n       */\n\n      const originalRook = currentBoard[castle.y][castle.x].getPiece();\n      currentBoard[castle.to_y][castle.to_x].setPiece(originalRook);\n      currentBoard[castle.y][castle.x].setPiece(null);\n    }\n\n    // ___actually changing the board model___\n\n    const reassign = isPromotion ? currentBoard[to_y][to_x].setPiece(new ChessPiece('queen', false, pieceId[0] === 'w' ? 'white' : 'black', pieceId[0] === 'w' ? 'wq' + this.nQueens : 'bq' + this.nQueens)) : currentBoard[to_y][to_x].setPiece(originalPiece);\n    if (reassign !== \"user tried to capture their own piece\") {\n      currentBoard[y][x].setPiece(null);\n    } else {\n      return reassign;\n    }\n\n    // ___actually changing the board model___\n\n    const checkMate = this.chess.isCheckmate() ? \" has been checkmated\" : \" has not been checkmated\";\n    console.log(this.chess.turn() + checkMate);\n    if (checkMate === \" has been checkmated\") {\n      return this.chess.turn() + checkMate;\n    }\n    // changes the fill color of the opponent's king that is in check\n    const check = this.chess.inCheck() ? \" is in check\" : \" is not in check\";\n    console.log(this.chess.turn() + check);\n    if (check === \" is in check\") {\n      return this.chess.turn() + check;\n    }\n    console.log(currentBoard);\n    // update board\n    this.setBoard(currentBoard);\n  }\n  isCastle(moveAttempt) {\n    /**\n     * Assume moveAttempt is legal. \n     * \n     * {moveAttempt} -> {boolean x, y to_x, to_y} \n     * \n     * returns if a player has castled, the final position of \n     * the rook (to_x, to_y), and the original position of the rook (x, y)\n     * \n     */\n\n    const piece = moveAttempt.piece;\n    const move = {\n      from: moveAttempt.from,\n      to: moveAttempt.to\n    };\n    const isBlackCastle = move.from === 'e1' && move.to === 'g1' || move.from === 'e1' && move.to === 'c1';\n    const isWhiteCastle = move.from === 'e8' && move.to === 'g8' || move.from === 'e8' && move.to === 'c8';\n    if (!(isWhiteCastle || isBlackCastle) || piece !== 'k') {\n      return {\n        didCastle: false\n      };\n    }\n    let originalPositionOfRook;\n    let newPositionOfRook;\n    if (move.from === 'e1' && move.to === 'g1') {\n      originalPositionOfRook = 'h1';\n      newPositionOfRook = 'f1';\n    } else if (move.from === 'e1' && move.to === 'c1') {\n      originalPositionOfRook = 'a1';\n      newPositionOfRook = 'd1';\n    } else if (move.from === 'e8' && move.to === 'g8') {\n      originalPositionOfRook = 'h8';\n      newPositionOfRook = 'f8';\n    } else {\n      // e8 to c8\n      originalPositionOfRook = 'a8';\n      newPositionOfRook = 'd8';\n    }\n    return {\n      didCastle: true,\n      x: this.toAlphabet2[originalPositionOfRook[0]],\n      y: this.toCoord2[originalPositionOfRook[1]],\n      to_x: this.toAlphabet2[newPositionOfRook[0]],\n      to_y: this.toCoord2[newPositionOfRook[1]]\n    };\n  }\n  isPawnPromotion(to, piece) {\n    const res = piece === 'p' && (to[1] === 105 || to[1] === 735);\n    if (res) {\n      this.nQueens += 1;\n    }\n    return res;\n  }\n  toChessMove(finalPosition, to2D) {\n    let move;\n    if (finalPosition[0] > 100) {\n      move = this.toAlphabet[to2D[finalPosition[0]]] + this.toCoord[to2D[finalPosition[1]]];\n    } else {\n      move = this.toAlphabet[finalPosition[0]] + this.toCoord[finalPosition[1]];\n    }\n\n    //  console.log(\"proposed move: \" + move)\n    return move;\n  }\n  findPiece(board, pieceId) {\n    // ChessBoard, String -> [Int, Int]\n    //  console.log(\"piecetofind: \" + pieceId)\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        if (board[i][j].getPieceIdOnThisSquare() === pieceId) {\n          return [j, i];\n        }\n      }\n    }\n  }\n  makeStartingBoard() {\n    const backRank = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"];\n    var startingChessBoard = [];\n    for (var i = 0; i < 8; i++) {\n      startingChessBoard.push([]);\n      for (var j = 0; j < 8; j++) {\n        // j is horizontal\n        // i is vertical\n        const coordinatesOnCanvas = [(j + 1) * 90 + 15, (i + 1) * 90 + 15];\n        const emptySquare = new Square(j, i, null, coordinatesOnCanvas);\n        startingChessBoard[i].push(emptySquare);\n      }\n    }\n    const whiteBackRankId = [\"wr1\", \"wn1\", \"wb1\", \"wq1\", \"wk1\", \"wb2\", \"wn2\", \"wr2\"];\n    const blackBackRankId = [\"br1\", \"bn1\", \"bb1\", \"bq1\", \"bk1\", \"bb2\", \"bn2\", \"br2\"];\n    for (j = 0; j < 8; j += 7) {\n      for (i = 0; i < 8; i++) {\n        if (j === 0) {\n          // top\n          // console.log(backRank[i])\n          startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? blackBackRankId[i] : whiteBackRankId[i]));\n          startingChessBoard[j + 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? \"bp\" + i : \"wp\" + i));\n        } else {\n          // bottom\n          startingChessBoard[j - 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? \"wp\" + i : \"bp\" + i));\n          startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? whiteBackRankId[i] : blackBackRankId[i]));\n        }\n      }\n    }\n    return startingChessBoard;\n  }\n}\nexport default Game;","map":{"version":3,"names":["Chess","ChessPiece","Square","Game","constructor","thisPlayersColorIsWhite","chessBoard","makeStartingBoard","chess","toCoord","toAlphabet","toCoord2","toAlphabet2","nQueens","getBoard","setBoard","newBoard","movePiece","pieceId","to","isMyMove","to2D","currentBoard","pieceCoordinates","findPiece","y","x","to_y","to_x","originalPiece","getPiece","isPromotion","isPawnPromotion","moveAttempt","move","from","toChessMove","piece","promotion","console","log","flags","color","parseInt","setPiece","castle","isCastle","didCastle","originalRook","reassign","checkMate","isCheckmate","turn","check","inCheck","isBlackCastle","isWhiteCastle","originalPositionOfRook","newPositionOfRook","res","finalPosition","board","i","j","getPieceIdOnThisSquare","backRank","startingChessBoard","push","coordinatesOnCanvas","emptySquare","whiteBackRankId","blackBackRankId"],"sources":["/Users/praneetha18/Downloads/games-app-main/src/components/Chess/model/Chess.js"],"sourcesContent":["import { Chess } from 'chess.js'\nimport ChessPiece from './ChessPiece'\nimport Square from './Square'\n// when indexing, remember: [y][x]. \n/**\n * If the player color is black, make sure to invert the board.\n */\n\n\nclass Game {\n    constructor(thisPlayersColorIsWhite) {\n        this.thisPlayersColorIsWhite = thisPlayersColorIsWhite // once initialized, this value should never change.\n        // console.log(\"this player's color is white: \" + this.thisPlayersColorIsWhite) \n        this.chessBoard = this.makeStartingBoard() // the actual chessBoard\n        this.chess = new Chess()\n\n        this.toCoord = thisPlayersColorIsWhite ? {\n            0: 8, 1: 7, 2: 6, 3: 5, 4: 4, 5: 3, 6: 2, 7: 1\n        } : {\n            0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8\n        }\n\n        this.toAlphabet = thisPlayersColorIsWhite ? {\n            0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\", 4: \"e\", 5: \"f\", 6: \"g\", 7: \"h\"\n        } : {\n            0: \"h\", 1: \"g\", 2: \"f\", 3: \"e\", 4: \"d\", 5: \"c\", 6: \"b\", 7: \"a\"\n        }\n\n        this.toCoord2 = thisPlayersColorIsWhite ? {\n            8: 0, 7: 1, 6: 2, 5: 3, 4: 4, 3: 5, 2: 6, 1: 7\n        } : {\n            1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7\n        }\n\n        this.toAlphabet2 = thisPlayersColorIsWhite ? {\n            \"a\": 0, \"b\": 1, \"c\": 2, \"d\": 3, \"e\": 4, \"f\": 5, \"g\": 6, \"h\": 7\n        } : {\n            \"h\": 0, \"g\": 1, \"f\": 2, \"e\": 3, \"d\": 4, \"c\": 5, \"b\": 6, \"a\": 7\n        }\n\n        this.nQueens = 1\n    }\n\n    getBoard() {\n        return this.chessBoard\n    }\n\n    // nextPlayersTurn() {\n    //     this.isWhitesTurn = !this.isWhitesTurn\n    // }\n\n    setBoard(newBoard) {\n        this.chessBoard = newBoard\n    }\n\n    movePiece(pieceId, to, isMyMove) {\n\n        const to2D = isMyMove ? {\n            105: 0, 195: 1, 285: 2, 375: 3, 465: 4, 555: 5, 645: 6, 735: 7\n        } : {\n            105: 7, 195: 6, 285: 5, 375: 4, 465: 3, 555: 2, 645: 1, 735: 0\n        }\n\n\n        var currentBoard = this.getBoard()\n        const pieceCoordinates = this.findPiece(currentBoard, pieceId)\n\n\n        // can't find piece coordinates (piece doesn't exist on the board)\n        if (!pieceCoordinates) {\n            return\n        }\n\n        const y = pieceCoordinates[1]\n        const x = pieceCoordinates[0]\n\n        // new coordinates\n        const to_y = to2D[to[1]]\n        const to_x = to2D[to[0]]\n\n        const originalPiece = currentBoard[y][x].getPiece()\n\n        if (y === to_y && x === to_x) {\n            return \"moved in the same position.\"\n        }\n\n        /**\n         * In order for this method to do anything meaningful, \n         * the 'reassign const' line of code must run. Therefore, \n         * for it to run, we must check first that the given move is valid. \n         */\n\n        const isPromotion = this.isPawnPromotion(to, pieceId[1])\n        const moveAttempt = !isPromotion ? this.chess.move({\n            from: this.toChessMove([x, y], to2D),\n            to: this.toChessMove(to, to2D),\n            piece: pieceId[1]\n        })\n            :\n            this.chess.move({\n                from: this.toChessMove([x, y], to2D),\n                to: this.toChessMove(to, to2D),\n                piece: pieceId[1],\n                promotion: 'q'\n            })\n\n\n        console.log(moveAttempt)\n        // console.log(isPromotion)\n\n        if (moveAttempt === null) {\n            return \"invalid move\"\n        }\n\n\n        if (moveAttempt.flags === 'e') {\n            const move = moveAttempt.to\n            const x = this.toAlphabet2[move[0]]\n            let y\n            if (moveAttempt.color === 'w') {\n                y = parseInt(move[1], 10) - 1\n            } else {\n                y = parseInt(move[1], 10) + 1\n            }\n            currentBoard[this.toCoord2[y]][x].setPiece(null)\n        }\n\n\n\n        // Check castling\n        const castle = this.isCastle(moveAttempt)\n        if (castle.didCastle) {\n            /**\n             *  The main thing we are doing here is moving the right rook\n             *  to the right position. \n             * \n             * - Get original piece by calling getPiece() on the original [x, y]\n             * - Set the new [to_x, to_y] to the original piece\n             * - Set the original [x, y] to null\n             */\n\n            const originalRook = currentBoard[castle.y][castle.x].getPiece()\n            currentBoard[castle.to_y][castle.to_x].setPiece(originalRook)\n            currentBoard[castle.y][castle.x].setPiece(null)\n        }\n\n\n        // ___actually changing the board model___\n\n        const reassign = isPromotion ? currentBoard[to_y][to_x].setPiece(\n            new ChessPiece(\n                'queen',\n                false,\n                pieceId[0] === 'w' ? 'white' : 'black',\n                pieceId[0] === 'w' ? 'wq' + this.nQueens : 'bq' + this.nQueens))\n            : currentBoard[to_y][to_x].setPiece(originalPiece)\n\n        if (reassign !== \"user tried to capture their own piece\") {\n            currentBoard[y][x].setPiece(null)\n        } else {\n            return reassign\n        }\n\n        // ___actually changing the board model___\n\n        \n        const checkMate = this.chess.isCheckmate() ? \" has been checkmated\" : \" has not been checkmated\"\n        console.log(this.chess.turn() + checkMate)\n        if (checkMate === \" has been checkmated\") {\n            return this.chess.turn() + checkMate\n        }\n        // changes the fill color of the opponent's king that is in check\n        const check = this.chess.inCheck() ? \" is in check\" : \" is not in check\"\n        console.log(this.chess.turn() + check)\n        if (check === \" is in check\") {\n            return this.chess.turn() + check\n        }\n\n        console.log(currentBoard)\n        // update board\n        this.setBoard(currentBoard)\n    }\n\n\n\n    isCastle(moveAttempt) {\n        /**\n         * Assume moveAttempt is legal. \n         * \n         * {moveAttempt} -> {boolean x, y to_x, to_y} \n         * \n         * returns if a player has castled, the final position of \n         * the rook (to_x, to_y), and the original position of the rook (x, y)\n         * \n         */\n\n\n        const piece = moveAttempt.piece\n        const move = { from: moveAttempt.from, to: moveAttempt.to }\n\n        const isBlackCastle = ((move.from === 'e1' && move.to === 'g1') || (move.from === 'e1' && move.to === 'c1'))\n        const isWhiteCastle = (move.from === 'e8' && move.to === 'g8') || (move.from === 'e8' && move.to === 'c8')\n\n\n        if (!(isWhiteCastle || isBlackCastle) || piece !== 'k') {\n            return {\n                didCastle: false\n            }\n        }\n\n        let originalPositionOfRook\n        let newPositionOfRook\n\n        if ((move.from === 'e1' && move.to === 'g1')) {\n            originalPositionOfRook = 'h1'\n            newPositionOfRook = 'f1'\n        } else if ((move.from === 'e1' && move.to === 'c1')) {\n            originalPositionOfRook = 'a1'\n            newPositionOfRook = 'd1'\n        } else if ((move.from === 'e8' && move.to === 'g8')) {\n            originalPositionOfRook = 'h8'\n            newPositionOfRook = 'f8'\n        } else { // e8 to c8\n            originalPositionOfRook = 'a8'\n            newPositionOfRook = 'd8'\n        }\n\n\n        return {\n            didCastle: true,\n            x: this.toAlphabet2[originalPositionOfRook[0]],\n            y: this.toCoord2[originalPositionOfRook[1]],\n            to_x: this.toAlphabet2[newPositionOfRook[0]],\n            to_y: this.toCoord2[newPositionOfRook[1]]\n        }\n    }\n\n\n    isPawnPromotion(to, piece) {\n        const res = piece === 'p' && (to[1] === 105 || to[1] === 735)\n        if (res) {\n            this.nQueens += 1\n        }\n        return res\n    }\n\n\n    toChessMove(finalPosition, to2D) {\n\n        let move\n\n        if (finalPosition[0] > 100) {\n            move = this.toAlphabet[to2D[finalPosition[0]]] + this.toCoord[to2D[finalPosition[1]]]\n        } else {\n            move = this.toAlphabet[finalPosition[0]] + this.toCoord[finalPosition[1]]\n        }\n\n        //  console.log(\"proposed move: \" + move)\n        return move\n    }\n\n    findPiece(board, pieceId) {\n        // ChessBoard, String -> [Int, Int]\n        //  console.log(\"piecetofind: \" + pieceId)\n        for (var i = 0; i < 8; i++) {\n            for (var j = 0; j < 8; j++) {\n                if (board[i][j].getPieceIdOnThisSquare() === pieceId) {\n                    return [j, i]\n                }\n            }\n        }\n    }\n\n    makeStartingBoard() {\n        const backRank = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"]\n        var startingChessBoard = []\n        for (var i = 0; i < 8; i++) {\n            startingChessBoard.push([])\n            for (var j = 0; j < 8; j++) {\n                // j is horizontal\n                // i is vertical\n                const coordinatesOnCanvas = [((j + 1) * 90 + 15), ((i + 1) * 90 + 15)]\n                const emptySquare = new Square(j, i, null, coordinatesOnCanvas)\n\n                startingChessBoard[i].push(emptySquare)\n            }\n        }\n        const whiteBackRankId = [\"wr1\", \"wn1\", \"wb1\", \"wq1\", \"wk1\", \"wb2\", \"wn2\", \"wr2\"]\n        const blackBackRankId = [\"br1\", \"bn1\", \"bb1\", \"bq1\", \"bk1\", \"bb2\", \"bn2\", \"br2\"]\n        for (j = 0; j < 8; j += 7) {\n            for (i = 0; i < 8; i++) {\n                if (j === 0) {\n                    // top\n                    // console.log(backRank[i])\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? blackBackRankId[i] : whiteBackRankId[i]))\n                    startingChessBoard[j + 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? \"bp\" + i : \"wp\" + i))\n                } else {\n                    // bottom\n                    startingChessBoard[j - 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? \"wp\" + i : \"bp\" + i))\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? whiteBackRankId[i] : blackBackRankId[i]))\n                }\n            }\n        }\n        return startingChessBoard\n    }\n}\n\nexport default Game"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}