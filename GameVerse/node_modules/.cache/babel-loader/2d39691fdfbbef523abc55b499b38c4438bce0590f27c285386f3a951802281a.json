{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nexports.SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n  return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\nfunction validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}\nexports.validateFen = validateFen;\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece) {\n  let captured = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  let flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BITS.NORMAL;\n  const r = rank(to);\n  if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return exports.PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return exports.KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n  constructor() {\n    let fen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.DEFAULT_POSITION;\n    this._board = new Array(128);\n    this._turn = exports.WHITE;\n    this._header = {};\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._epSquare = -1;\n    this._halfMoves = 0;\n    this._moveNumber = 0;\n    this._history = [];\n    this._comments = {};\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this.load(fen);\n  }\n  clear() {\n    let keepHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = exports.WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = keepHeaders ? this._header : {};\n    this._updateSetup(this.fen());\n  }\n  load(fen) {\n    let keepHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let tokens = fen.split(/\\s+/);\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1'];\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n    }\n    tokens = fen.split(/\\s+/);\n    const {\n      ok,\n      error\n    } = validateFen(fen);\n    if (!ok) {\n      throw new Error(error);\n    }\n    const position = tokens[0];\n    let square = 0;\n    this.clear(keepHeaders);\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n        this.put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n    this._turn = tokens[1];\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n    this._updateSetup(this.fen());\n  }\n  fen() {\n    var _a, _b;\n    let empty = 0;\n    let fen = '';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n        empty = 0;\n        i += 8;\n      }\n    }\n    let castling = '';\n    if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K';\n    }\n    if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q';\n    }\n    if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k';\n    }\n    if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q';\n    }\n    // do we have an empty castling flag?\n    castling = castling || '-';\n    let epSquare = '-';\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue;\n        }\n        const color = this._turn;\n        // is there a pawn that can capture the epSquare?\n        if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color && ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === exports.PAWN) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: exports.PAWN,\n            captured: exports.PAWN,\n            flags: BITS.EP_CAPTURE\n          });\n          const isLegal = !this._isKingAttacked(color);\n          this._undoMove();\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare);\n            break;\n          }\n        }\n      }\n    }\n    return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n  }\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n    if (fen !== exports.DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      delete this._header['SetUp'];\n      delete this._header['FEN'];\n    }\n  }\n  reset() {\n    this.load(exports.DEFAULT_POSITION);\n  }\n  get(square) {\n    return this._board[Ox88[square]] || false;\n  }\n  put(_ref, square) {\n    let {\n      type,\n      color\n    } = _ref;\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    }\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false;\n    }\n    const sq = Ox88[square];\n    // don't let the user place more than one king\n    if (type == exports.KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n    this._board[sq] = {\n      type: type,\n      color: color\n    };\n    if (type === exports.KING) {\n      this._kings[color] = sq;\n    }\n    this._updateSetup(this.fen());\n    return true;\n  }\n  remove(square) {\n    const piece = this.get(square);\n    delete this._board[Ox88[square]];\n    if (piece && piece.type === exports.KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n    this._updateSetup(this.fen());\n    return piece;\n  }\n  _attacked(color, square) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n      const piece = this._board[i];\n      const difference = i - square;\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue;\n      }\n      const index = difference + 119;\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === exports.PAWN) {\n          if (difference > 0) {\n            if (piece.color === exports.WHITE) return true;\n          } else {\n            if (piece.color === exports.BLACK) return true;\n          }\n          continue;\n        }\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n          j += offset;\n        }\n        if (!blocked) return true;\n      }\n    }\n    return false;\n  }\n  _isKingAttacked(color) {\n    return this._attacked(swapColor(color), this._kings[color]);\n  }\n  isAttacked(square, attackedBy) {\n    return this._attacked(attackedBy, Ox88[square]);\n  }\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n  inCheck() {\n    return this.isCheck();\n  }\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      const piece = this._board[i];\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n        if (piece.type === exports.BISHOP) {\n          bishops.push(squareColor);\n        }\n        numPieces++;\n      }\n    }\n    // k vs. k\n    if (numPieces === 2) {\n      return true;\n    } else if (\n    // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[exports.BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isThreefoldRepetition() {\n    const moves = [];\n    const positions = {};\n    let repetition = false;\n    while (true) {\n      const move = this._undoMove();\n      if (!move) break;\n      moves.push(move);\n    }\n    while (true) {\n      /*\n       * remove the last two fields in the FEN string, they're not needed when\n       * checking for draw by rep\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ');\n      // has the position occurred three or move times\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n      const move = moves.pop();\n      if (!move) {\n        break;\n      } else {\n        this._makeMove(move);\n      }\n    }\n    return repetition;\n  }\n  isDraw() {\n    return this._halfMoves >= 100 ||\n    // 50 moves per side = 100 half moves\n    this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw();\n  }\n  moves() {\n    let {\n      verbose = false,\n      square = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const moves = this._moves({\n      square\n    });\n    if (verbose) {\n      return moves.map(move => this._makePretty(move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n  _moves() {\n    let {\n      legal = true,\n      piece = undefined,\n      square = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false;\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      }\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n      const {\n        type\n      } = this._board[from];\n      let to;\n      if (type === exports.PAWN) {\n        if (forPiece && forPiece !== type) continue;\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0];\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, exports.PAWN);\n          // double square\n          to = from + PAWN_OFFSETS[us][1];\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n          }\n        }\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n          if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n            addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n            if (type === exports.KNIGHT || type === exports.KING) break;\n          }\n        }\n      }\n    }\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n    if (forPiece === undefined || forPiece === exports.KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        }\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves;\n    }\n    // filter out illegal moves\n    const legalMoves = [];\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n      this._undoMove();\n    }\n    return legalMoves;\n  }\n  move(move) {\n    let {\n      strict = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n    let moveObj = null;\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict);\n    } else if (typeof move === 'object') {\n      const moves = this._moves();\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    }\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`);\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n      }\n    }\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj);\n    this._makeMove(moveObj);\n    return prettyMove;\n  }\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n    this._push(move);\n    this._board[move.to] = this._board[move.from];\n    delete this._board[move.from];\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === exports.BLACK) {\n        delete this._board[move.to - 16];\n      } else {\n        delete this._board[move.to + 16];\n      }\n    }\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    // if we moved the king\n    if (this._board[move.to].type === exports.KING) {\n      this._kings[us] = move.to;\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      // turn off castling\n      this._castling[us] = 0;\n    }\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === exports.BLACK) {\n        this._epSquare = move.to - 16;\n      } else {\n        this._epSquare = move.to + 16;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    }\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === exports.PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n    if (us === exports.BLACK) {\n      this._moveNumber++;\n    }\n    this._turn = them;\n  }\n  undo() {\n    const move = this._undoMove();\n    return move ? this._makePretty(move) : null;\n  }\n  _undoMove() {\n    const old = this._history.pop();\n    if (old === undefined) {\n      return null;\n    }\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._board[move.from] = this._board[move.to];\n    this._board[move.from].type = move.piece; // to undo any promotions\n    delete this._board[move.to];\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n        if (us === exports.BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n        this._board[index] = {\n          type: exports.PAWN,\n          color: them\n        };\n      } else {\n        // regular capture\n        this._board[move.to] = {\n          type: move.captured,\n          color: them\n        };\n      }\n    }\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n      this._board[castlingTo] = this._board[castlingFrom];\n      delete this._board[castlingFrom];\n    }\n    return move;\n  }\n  pgn() {\n    let {\n      newline = '\\n',\n      maxWidth = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n      headerExists = true;\n    }\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = `${moveString}${delimiter}{${comment}}`;\n      }\n      return moveString;\n    };\n    // pop all of history onto reversed_history\n    const reversedHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    const moves = [];\n    let moveString = '';\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    }\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop();\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break;\n      }\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`;\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix;\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n        moveString = this._moveNumber + '.';\n      }\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n      this._makeMove(move);\n    }\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    }\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result);\n    }\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    }\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n      return false;\n    };\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n          result.push(newline);\n          width = 0;\n        }\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n      if (strip()) {\n        width--;\n      }\n      return width;\n    };\n    // wrap the PGN output at max_width\n    let currentWidth = 0;\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n    return result.join('');\n  }\n  header() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n    return this._header;\n  }\n  loadPgn(pgn) {\n    let {\n      strict = false,\n      newlineChar = '\\r?\\n'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    function mask(str) {\n      return str.replace(/\\\\/g, '\\\\');\n    }\n    function parsePgnHeader(header) {\n      const headerObj = {};\n      const headers = header.split(new RegExp(mask(newlineChar)));\n      let key = '';\n      let value = '';\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n        key = headers[i].replace(regex, '$1');\n        value = headers[i].replace(regex, '$2');\n        if (key.trim().length > 0) {\n          headerObj[key] = value;\n        }\n      }\n      return headerObj;\n    }\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim();\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)');\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn);\n    const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n    // Put the board in the starting position\n    this.reset();\n    // parse PGN header\n    const headers = parsePgnHeader(headerString);\n    let fen = '';\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n      this.header(key, headers[key]);\n    }\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true);\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n        }\n        // second argument to load: don't clear the headers\n        this.load(headers['FEN'], true);\n      }\n    }\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n    function toHex(s) {\n      return Array.from(s).map(function (c) {\n        /*\n         * encodeURI doesn't transform most ASCII characters, so we handle\n         * these ourselves\n         */\n        return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n      }).join('');\n    }\n    function fromHex(s) {\n      return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n    }\n    const encodeComment = function (s) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      return `{${toHex(s.slice(1, s.length - 1))}}`;\n    };\n    const decodeComment = function (s) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1));\n      }\n    };\n    // delete header to get the moves\n    let ms = pgn.replace(headerString, '').replace(\n    // encode comments so they don't get deleted below\n    new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n      return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n    }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g;\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '');\n    }\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '');\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '');\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/));\n    // delete empty entries\n    moves = moves.filter(move => move !== '');\n    let result = '';\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove]);\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment;\n        continue;\n      }\n      const move = this._moveFromSan(moves[halfMove], strict);\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove];\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = '';\n        this._makeMove(move);\n      }\n    }\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result);\n    }\n  }\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  _moveToSan(move, moves) {\n    let output = '';\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== exports.PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === exports.PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n      output += algebraic(move.to);\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n    this._makeMove(move);\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    this._undoMove();\n    return output;\n  }\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  _moveFromSan(move) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move);\n    let pieceType = inferPieceType(cleanMove);\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    });\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    }\n    // the strict parser failed\n    if (strict) {\n      return null;\n    }\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined;\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n    //     piece         from              to       promotion\n    );\n\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (from && to) {\n        // hand-compare move properties with the results from our permissive regex\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        } else if (overlyDisambiguated) {\n          /*\n           * SPECIAL CASE: we parsed a move string that may have an unneeded\n           * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n           */\n          const square = algebraic(moves[i].from);\n          if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n            return moves[i];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  ascii() {\n    let s = '   +------------------------+\\n';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n    let nodes = 0;\n    const color = this._turn;\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n      this._undoMove();\n    }\n    return nodes;\n  }\n  // pretty = external move object\n  _makePretty(uglyMove) {\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = uglyMove;\n    let prettyFlags = '';\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag];\n      }\n    }\n    const fromAlgebraic = algebraic(from);\n    const toAlgebraic = algebraic(to);\n    const move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({\n        legal: true\n      })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic\n    };\n    if (captured) {\n      move.captured = captured;\n    }\n    if (promotion) {\n      move.promotion = promotion;\n      move.lan += promotion;\n    }\n    return move;\n  }\n  turn() {\n    return this._turn;\n  }\n  board() {\n    const output = [];\n    let row = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n    return output;\n  }\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n    return null;\n  }\n  history() {\n    let {\n      verbose = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const reversedHistory = [];\n    const moveHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      if (verbose) {\n        moveHistory.push(Object.assign({\n          fen: this.fen()\n        }, this._makePretty(move)));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n      this._makeMove(move);\n    }\n    return moveHistory;\n  }\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    copyComment(this.fen());\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      this._makeMove(move);\n      copyComment(this.fen());\n    }\n    this._comments = currentComments;\n  }\n  getComment() {\n    return this._comments[this.fen()];\n  }\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n  deleteComment() {\n    const comment = this._comments[this.fen()];\n    delete this._comments[this.fen()];\n    return comment;\n  }\n  getComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n  deleteComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n}\nexports.Chess = Chess;","map":{"version":3,"names":["Object","defineProperty","exports","value","Chess","validateFen","SQUARES","DEFAULT_POSITION","KING","QUEEN","ROOK","BISHOP","KNIGHT","PAWN","BLACK","WHITE","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","fen","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","kings","regex","match","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","captured","undefined","flags","promotion","push","inferPieceType","san","pieceType","matches","toLowerCase","strippedSan","replace","constructor","_board","Array","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","load","clear","keepHeaders","_updateSetup","adjustments","concat","slice","join","Error","position","put","type","_a","_b","empty","toUpperCase","castling","epSquare","bigPawnSquare","squares","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","sq","remove","_attacked","difference","index","offset","j","blocked","isAttacked","attackedBy","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","positions","repetition","pop","isDraw","isGameOver","verbose","map","_makePretty","_moveToSan","legal","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","undo","old","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","args","loadPgn","newlineChar","mask","str","parsePgnHeader","headerObj","headers","RegExp","key","trim","headerRegex","headerRegexResults","exec","headerString","toHex","s","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","symbol","perft","depth","nodes","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","board","row","history","moveHistory","assign","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments"],"sources":["/Users/praneetha18/Downloads/games-app-main/node_modules/chess.js/dist/chess.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexports.SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    return { ok: true };\n}\nexports.validateFen = validateFen;\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return exports.PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return exports.KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    constructor(fen = exports.DEFAULT_POSITION) {\n        this._board = new Array(128);\n        this._turn = exports.WHITE;\n        this._header = {};\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = { w: 0, b: 0 };\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = exports.WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    load(fen, keepHeaders = false) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        const { ok, error } = validateFen(fen);\n        if (!ok) {\n            throw new Error(error);\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n    }\n    fen() {\n        var _a, _b;\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color &&\n                    ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === exports.PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: exports.PAWN,\n                        captured: exports.PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== exports.DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(exports.DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == exports.KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === exports.KING) {\n            this._kings[color] = sq;\n        }\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === exports.KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === exports.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === exports.WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === exports.BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        return this._attacked(swapColor(color), this._kings[color]);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === exports.BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /*\n             * remove the last two fields in the FEN string, they're not needed when\n             * checking for draw by rep\n             */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            // has the position occurred three or move times\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, } = {}) {\n        const moves = this._moves({ square });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        var _a;\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === exports.PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, exports.PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === exports.KNIGHT || type === exports.KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === exports.KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === exports.BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === exports.KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === exports.BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === exports.PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === exports.BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === exports.BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: exports.PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, true);\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // second argument to load: don't clear the headers\n                this.load(headers['FEN'], true);\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== exports.PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === exports.PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (from && to) {\n                // hand-compare move properties with the results from our permissive regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[from] == moves[i].from &&\n                    Ox88[to] == moves[i].to &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n                else if (overlyDisambiguated) {\n                    /*\n                     * SPECIAL CASE: we parsed a move string that may have an unneeded\n                     * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                     */\n                    const square = algebraic(moves[i].from);\n                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                        Ox88[to] == moves[i].to &&\n                        (from == square[0] || from == square[1]) &&\n                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                        return moves[i];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n        };\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(Object.assign({ fen: this.fen() }, this._makePretty(move)));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n}\nexports.Chess = Chess;\n"],"mappings":"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AE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CACjD;AACD;AACA,MAAMC,IAAI,GAAG,CACT,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EACjD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EACrD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE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"},"metadata":{},"sourceType":"script","externalDependencies":[]}